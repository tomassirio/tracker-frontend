name: Helm Deploy to Kubernetes

on:
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment (dev, staging, prod)'
        required: true
        type: string
      image-tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
      namespace:
        description: 'Kubernetes namespace'
        required: false
        type: string
        default: 'wanderer'
    secrets:
      # Twingate
      TWINGATE_SERVICE_KEY:
        description: 'Twingate service key for cluster access'
        required: true

      # Kubernetes
      KUBECONFIG_CONTENT:
        description: 'Base64 encoded kubeconfig file'
        required: true

      # Application Secrets
      GOOGLE_MAPS_API_KEY:
        description: 'Google Maps API Key'
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Connect to Twingate
        uses: twingate/github-action@v1
        with:
          service-key: ${{ secrets.TWINGATE_SERVICE_KEY }}

      - name: Setup Kubernetes
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_CONTENT }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          
          # Skip TLS verification for self-signed certificates
          CLUSTER_NAME=$(kubectl config view -o jsonpath='{.clusters[0].name}')
          kubectl config set-cluster "$CLUSTER_NAME" --insecure-skip-tls-verify=true
          
          echo "Testing cluster connection..."
          kubectl cluster-info
          kubectl get nodes
          echo "✓ Successfully connected to Kubernetes cluster"

      - name: Update Chart.yaml versions
        run: |
          # For dev: use SNAPSHOT version from pubspec.yaml
          # For prod: use image-tag (released version)
          if [ "${{ inputs.environment }}" == "dev" ]; then
            # Extract SNAPSHOT version from pubspec.yaml for dev
            VERSION=$(grep '^version:' pubspec.yaml | sed 's/version: *//' | sed 's/+.*//')
            echo "Dev environment: Using SNAPSHOT version from pubspec.yaml: $VERSION"
          else
            # Use image-tag for production (released version)
            VERSION="${{ inputs.image-tag }}"
            # Remove 'v' prefix if present
            VERSION="${VERSION#v}"
            echo "Production environment: Using released version: $VERSION"
          fi
          
          # Update version in Chart.yaml
          CHART_FILE="./chart/Chart.yaml"
          if [ -f "$CHART_FILE" ]; then
            sed -i "s/^version: .*/version: $VERSION/" "$CHART_FILE"
            sed -i "s/^appVersion: .*/appVersion: \"$VERSION\"/" "$CHART_FILE"
            echo "Updated $CHART_FILE to version $VERSION"
            cat "$CHART_FILE"
          else
            echo "Error: Chart.yaml not found at $CHART_FILE"
            exit 1
          fi

      - name: Deploy Tracker Frontend
        run: |
          echo "================================================"
          echo "Deploying tracker-frontend..."
          echo "================================================"
          
          # Check if release exists
          if helm list -n ${{ inputs.namespace }} --short | grep -q "^tracker-frontend$"; then
            echo "tracker-frontend exists, upgrading..."
            ACTION="upgrade"
          else
            echo "tracker-frontend does not exist, installing..."
            ACTION="install"
          fi
          
          # Set backend URLs and ingress hostname based on environment
          if [ "${{ inputs.environment }}" == "dev" ]; then
            # Dev environment uses 32xxx ports and -dev suffix on service names
            COMMAND_URL="http://tracker-command-dev:32001/api/1"
            QUERY_URL="http://tracker-query-dev:32002/api/1"
            AUTH_URL="http://tracker-auth-dev:32003/api/1"
            INGRESS_HOST="wanderer.localwanderer-dev.com"
          else
            # Production uses 42xxx ports and no suffix on service names
            COMMAND_URL="http://tracker-command:42001/api/1"
            QUERY_URL="http://tracker-query:42002/api/1"
            AUTH_URL="http://tracker-auth:42003/api/1"
            INGRESS_HOST="wanderer.localwanderer.com"
          fi
          
          # Deploy
          helm $ACTION tracker-frontend ./chart \
            --namespace ${{ inputs.namespace }} \
            --create-namespace \
            --set image.tag="${{ inputs.image-tag }}" \
            --set application.googleMapsApiKey="${{ secrets.GOOGLE_MAPS_API_KEY }}" \
            --set application.commandBaseUrl="$COMMAND_URL" \
            --set application.queryBaseUrl="$QUERY_URL" \
            --set application.authBaseUrl="$AUTH_URL" \
            --set ingress.hosts[0].host="$INGRESS_HOST" \
            --set ingress.hosts[0].paths[0].path="/" \
            --set ingress.hosts[0].paths[0].pathType="Prefix" \
            --wait --timeout 5m
          
          echo "✓ tracker-frontend deployed successfully"
          echo "Access at: http://$INGRESS_HOST"

      - name: Verify deployment
        run: |
          echo "=== Deployments ==="
          kubectl get deployments,statefulsets -n ${{ inputs.namespace }} -l app=tracker-frontend
          
          echo ""
          echo "=== Pods ==="
          kubectl get pods -n ${{ inputs.namespace }} -l app=tracker-frontend
          
          echo ""
          echo "=== Services ==="
          kubectl get services -n ${{ inputs.namespace }} -l app=tracker-frontend

      - name: Check pod health
        run: |
          echo "Checking pod health..."
          kubectl wait --for=condition=ready pod -l app=tracker-frontend \
            -n ${{ inputs.namespace }} --timeout=120s || true

      - name: Display pod logs on failure
        if: failure()
        run: |
          echo "=== tracker-frontend logs ==="
          kubectl logs -l app=tracker-frontend -n ${{ inputs.namespace }} --tail=100 || true

